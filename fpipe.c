#include "stdafx.h"

/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <WinSock.h>
//#include <defs.h>


//-------------------------------------------------------------------------
// Function declarations

void DebugPrint(char *Format, ...);
void DebugPrint1(char *Format, ...);
int main(int argc, const char **argv, const char **envp);
int Initialization(HINSTANCE hInstance);
int ExitProc();
int ParseCommandLine(int a1, char **a2);
int str2int(char **a1, int *a2);
int getIPfromHost(char **a1);
int resolveHostName(char *cp, int); // idb
int PipeProc();
int closeAllConnections();
void closeInOutConnections(SOCKET *a1);
DWORD *checkIfWeExceedMaxConnections();
DWORD *addConnectionToPool(SOCKET sock, int a2);
LPSTR DWORD2IpStr(int a1, LPSTR a2);
LRESULT __stdcall WndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
BOOL __stdcall HandlerRoutine(DWORD CtrlType); // idb
void PrintHelp();

//-------------------------------------------------------------------------
// Data declarations

// extern FILE iob[];
CHAR g_szWindowName[] = "FPipe"; // idb
char g_szAbout[] = "FPipe v2.1 - TCP/UDP port redirector.\nCopyright 2000 (c) by Foundstone, Inc.\nhttp://www.foundstone.com\n\n"; // idb
char g_szLocalhost[10] = "127.0.0.1"; // weak
char g_szUnableToConnect[36] = "Unable to connect to remote address"; // weak
char g_szWinsockErrorCode[20] = "Winsock error code "; // weak
char g_szUnableToStartNetwork[] = "Unable to start network communications\n"; // idb
char g_szSourceBindPort[] = "Source bind port number out of range\n"; // idb
char g_szRemotePortNumber[33] = "Remote port number out of range\n"; // weak
char aListeningPortN[36] = "Listening port number out of range\n"; // weak
char aUnableToCreate_2[] = "Unable to create UDP output socket\n"; // idb
char aUnableToCreate_1[35] = "Unable to create UDP input socket\n"; // weak
char aUnableToCreate_0[] = "Unable to create new pipe. Maximum number of connections is in use\n"; // idb
char aClosingInbound[] = "Closing inbound connection\n"; // idb
char aClosingOutboun[] = "Closing outbound connection\n"; // idb
char aUnableToCreate_3[] = "Unable to create output socket\n"; // idb
char aOutboundConnec[26] = "Outbound connection lost\n"; // weak
char aInboundConnect[] = "Inbound connection lost\n"; // idb
char aDataReceivedFr[] = "Data received from outbound connection but I don't know where to send it!\n"; // idb
char aQuitSignalDete[] = "\nQuit signal detected. Shutting down...\n"; // idb
char aDataSentToAndF[] = "Data sent to and from the connected machines will be passed through.\n"; // idb
char aSourcePortForT[] = "source port for that outbound connection being set to 53 also.\n"; // idb
char aMadeToPort80Of[] = "made to port 80 of the remote machine at 192.168.1.101 with the\n"; // idb
char aWhenALocalConn[] = "when a local connection is detected a further connection will be\n"; // idb
char aThisWouldSetTh[] = "This would set the program to listen for connections on port 53 and\n"; // idb
char aFpipeL53S53R80[] = "fpipe -l 53 -s 53 -r 80 192.168.1.101\n\n"; // idb
char aExample[] = "Example:\n"; // idb
char aVVerboseMode[] = " -v    - verbose mode\n\n"; // idb
char aUUdpMode[] = " -u    - UDP mode\n"; // idb
char aSOutboundSourc[] = " -s    - outbound source port number\n"; // idb
char aRRemotePortNum[] = " -r    - remote port number\n"; // idb
char aLListeningPort[] = " -l    - listening port number\n"; // idb
char aIListeningInte[] = " -i    - listening interface IP address\n"; // idb
char aHShowsThisHelp[] = " -?/-h - shows this help text\n"; // idb

CRITICAL_SECTION g_csSync = { NULL, 0, 0, NULL, NULL, 0u }; // idb
int dword_404C58 = 0; // weak
int g_quitSignal = 0; // weak
HWND g_hWnd = NULL; // idb
int g_destIP = 0; // weak
sockaddr g_sockTo = { 0u, "" }; // idb
int g_type = 0; // idb
int g_iFlagIP = 0; // idb
int g_UDPFlag = 0; // weak
SOCKET g_sock = 0u; // idb
u_short g_LFlagPort = 0u; // idb
char g_sockList[4096]; // weak
sockaddr g_sockaddr; // idb
DWORD maxConnections; // weak
u_short g_sFlagSourcePort; // idb
sockaddr g_sockAddrOut; // idb
u_short g_rFlagPort; // idb


//----- (00401000) --------------------------------------------------------
void DebugPrint(char *Format, ...)
{
  char Buffer[1024]; // [esp+0h] [ebp-400h] BYREF
  va_list va; // [esp+40Ch] [ebp+Ch] BYREF

  va_start(va, Format);
  vsprintf(Buffer, Format, va);
  //printf(&iob[2], Buffer);
  printf(Buffer);
  OutputDebugStringA(Buffer);
}

//----- (00401047) --------------------------------------------------------
void DebugPrint1(char *Format, ...)
{
  char Buffer[1024]; // [esp+0h] [ebp-400h] BYREF
  va_list va; // [esp+40Ch] [ebp+Ch] BYREF

  va_start(va, Format);
  if ( dword_404C58 )
  {
    vsprintf(Buffer, Format, va);
    printf(Buffer);
    OutputDebugStringA(Buffer);
  }
}
// 404C58: using guessed type int dword_404C58;

//----- (0040108D) --------------------------------------------------------
int main(int argc, const char **argv, const char **envp)
{
  //int v3; // esi
  HMODULE v4; // eax
  BOOL i; // eax
  MSG Msg; // [esp+8h] [ebp-1Ch] BYREF
  //int savedregs; // [esp+24h] [ebp+0h] BYREF

  v4 = GetModuleHandleA(0);
  if ( Initialization(v4) && ParseCommandLine(argc, (char **)argv) && PipeProc() )
  {
    for ( i = GetMessageA(&Msg, 0, 0, 0); i > 0; i = GetMessageA(&Msg, 0, 0, 0) )
    {
      TranslateMessage(&Msg);
      DispatchMessageA(&Msg);
    }
  }
  ExitProc();
  return 0;
}
// 4010BA: variable 'v3' is possibly undefined

//----- (004010FE) --------------------------------------------------------
int Initialization(HINSTANCE hInstance)
{
  WSAData wsaData; // [esp+Ch] [ebp-1B8h] BYREF
  WNDCLASSA WndClass; // [esp+19Ch] [ebp-28h] BYREF

  InitializeCriticalSection(&g_csSync);
  g_destIP = -1;
  g_sock = -1;
  g_hWnd = 0;
  g_quitSignal = 0;
  dword_404C58 = 0;
  g_UDPFlag = 0;
  g_type = 1;
  //*(DWORD *)&ArgList = 0;
  g_LFlagPort = 0;
  //*(DWORD *)&dword_407CA4 = 0;
  g_sFlagSourcePort = 0;
  //*(DWORD *)&dword_407CB8 = 0;
  g_rFlagPort = 0;
  g_iFlagIP = 0;
  maxConnections = 32;
  SetConsoleCtrlHandler(HandlerRoutine, 1);
  DebugPrint(g_szAbout);
  WndClass.hInstance = hInstance;
  WndClass.style = 0;
  WndClass.lpfnWndProc = WndProc;
  WndClass.cbClsExtra = 0;
  WndClass.cbWndExtra = 0;
  WndClass.hIcon = 0;
  WndClass.hCursor = 0;
  WndClass.hbrBackground = 0;
  WndClass.lpszMenuName = 0;
  WndClass.lpszClassName = g_szWindowName;
  RegisterClassA(&WndClass);
  g_hWnd = CreateWindowExA(
           0,
           g_szWindowName,
           g_szWindowName,
           0xCF0000u,
           0x80000000,
           0x80000000,
           0x80000000,
           0x80000000,
           0,
           0,
           hInstance,
           0);
  if ( !WSAStartup(1u, &wsaData) )
    return 1;
  DebugPrint(g_szUnableToStartNetwork);
  return 0;
}
// 404C58: using guessed type int dword_404C58;
// 404C5C: using guessed type int dword_404C5C;
// 404C64: using guessed type int dword_404C64;
// 404C80: using guessed type int dword_404C80;
// 407CA0: using guessed type int dword_407CA0;

//----- (004011FD) --------------------------------------------------------
int ExitProc()
{
  if ( g_hWnd )
  {
    DestroyWindow(g_hWnd);
    g_hWnd = 0;
  }
  if ( g_sock != -1 )
  {
    shutdown(g_sock, 2);
    closesocket(g_sock);
    g_sock = -1;
  }
  closeAllConnections();
  DeleteCriticalSection(&g_csSync);
  return WSACleanup();
}

//----- (00401250) --------------------------------------------------------
//argc, argv
int ParseCommandLine(int argc, char **argv)
{
  char *pszArg; // eax
  char v3; // bl
  int v4; // eax
  int v6; // [esp+Ch] [ebp-Ch] BYREF
  char *pArg; // [esp+10h] [ebp-8h] BYREF
  char ch; // [esp+17h] [ebp-1h]

  ch = 0;
  if ( argc < 4 )
  {
LABEL_57:
    PrintHelp();
    return 0;
  }

  do
  {
    pszArg = *++argv;
    for ( pArg = *argv; ; pszArg = pArg )
    {
      v3 = *pszArg;
      if ( !*pszArg )
        break;
      if ( ch )
      {
        v3 = ch;
        ch = 0;
      }
      else
      {
        ++pArg;
        if ( v3 == '-' )
          v3 = *pArg++;
      }

      if ( v3 > 'V' )
      {
        if ( v3 <= 'r' )
        {
          if ( v3 != 'r' )
          {
            if ( v3 != 'c' )
            {
              if ( v3 == 'h' )
                goto LABEL_57;
              if ( v3 == 105 )
                goto LABEL_31;
              if ( v3 != 108 )
                goto LABEL_44;
LABEL_27:
              if ( !str2int(&pArg, &v6) )
                goto LABEL_51;
              if ( v6 <= 0xFFFF )
                g_LFlagPort = (u_short)v6;//*(DWORD *)&ArgList = v6;
              else
                DebugPrint(aListeningPortN);
              continue;
            }
            goto LABEL_33;
          }
LABEL_37:
          if ( !str2int(&pArg, &v6) )
            goto LABEL_51;
          if ( v6 <= 0xFFFF )
            g_rFlagPort = (u_short)v6;//*(DWORD *)&dword_407CB8 = v6;
          else
            DebugPrint(g_szRemotePortNumber);
          continue;
        }
        if ( v3 != 's' )
        {
          if ( v3 != 'u' )
          {
            if ( v3 != 'v' )
              goto LABEL_44;
LABEL_45:
            dword_404C58 = 1;
            continue;
          }
          goto LABEL_46;
        }
      }
      else
      {
        if ( v3 == 'V' )
          goto LABEL_45;
        if ( v3 <= 'L' )
        {
          if ( v3 == 'L' )
            goto LABEL_27;
          if ( v3 == '?' )
            goto LABEL_57;
          if ( v3 != 'C' )
          {
            if ( v3 == 'H' )
              goto LABEL_57;
            if ( v3 != 'I' )
            {
LABEL_44:
              --pArg;
              g_destIP = getIPfromHost(&pArg);
              continue;
            }
LABEL_31:
            v4 = getIPfromHost(&pArg);
            if ( v4 != -1 )
            {
              g_iFlagIP = v4;
              continue;
            }
LABEL_51:
            ch = v3;
            continue;
          }
LABEL_33:
          if ( !str2int(&pArg, &v6) )
            goto LABEL_51;
          if ( v6 > 512 )
          {
            DebugPrint("Too many connections! Set to %d\n", 512);
            v6 = 512;
          }
          maxConnections = v6;
          continue;
        }
        if ( v3 == 'R' )
          goto LABEL_37;
        if ( v3 != 'S' )
        {
          if ( v3 != 'U' )
            goto LABEL_44;
LABEL_46:
          g_UDPFlag = 1;
          g_type = 2;
          continue;
        }
      }
      if ( !str2int(&pArg, &v6) )
        goto LABEL_51;
      if ( v6 <= 0xFFFF )
        g_sFlagSourcePort = (u_short)v6;//*(DWORD *)&dword_407CA4 = v6;
      else
        DebugPrint(g_szSourceBindPort);
    }
    --argc;
  }
  while ( argc > 1 );
  if ( g_destIP == -1 )
  {
    DebugPrint("No IP address provided - using %s\n", g_szLocalhost);
    pArg = g_szLocalhost;
    g_destIP = getIPfromHost(&pArg);
  }
  return 1;
}
// 40126B: conditional instruction was optimized away because of '%arg_0.4>=4'
// 404C58: using guessed type int dword_404C58;
// 404C64: using guessed type int dword_404C64;
// 404C80: using guessed type int dword_404C80;
// 407CA0: using guessed type int dword_407CA0;

//----- (004014A8) --------------------------------------------------------
int str2int(char **buf, int *n)
{
  int k; // ecx
  int result; // eax
  char *str; // edx
  char ch; // bl

  k = 0;
  result = 0;
  str = *buf;
  while ( 1 )
  {
    ch = *str++;
    if ( ch < '0' || ch > '9' )
      break;
    k = ch + 10 * k - '0';
    result = 1;
  }
  *buf = str - 1;
  *n = k;
  return result;
}
// 4014CE: conditional instruction was optimized away because of 'bl.1 in (30..39)'

//----- (004014DC) --------------------------------------------------------
int getIPfromHost(char **a1)
{
  unsigned int v1; // ecx
  char v2; // al
  char *v3; // esi
  int result; // eax
  char cp[256]; // [esp+8h] [ebp-100h] BYREF

  v1 = 0;
  v2 = **a1;
  v3 = *a1 + 1;
  if ( v2 != '"' )
    goto LABEL_3;
  while ( 1 )
  {
    v2 = *v3++;
LABEL_3:
    if ( !v2 || v2 == ',' || v2 == ':' || v2 == '"' || v2 == ' ' || v1 >= '\xFF' )
      break;
    cp[v1++] = v2;
  }
  cp[v1] = 0;
  result = resolveHostName(cp, 0);
  *a1 = v3 - 1;
  return result;
}

//----- (0040153D) --------------------------------------------------------
int resolveHostName(char *cp, int a2)
{
  int v2; // edi
  struct hostent *v3; // eax
  const char *v4; // eax
  CHAR v6[32]; // [esp+8h] [ebp-20h] BYREF

  v2 = -1;
  if ( cp && *cp )
  {
    v2 = inet_addr(cp);
    if ( v2 == -1 )
    {
      if ( a2 )
        *(DWORD *)a2 = 0;
      DebugPrint1("Looking up hostname \"%s\"\n", cp);
      v3 = gethostbyname(cp);
      if ( v3 )
      {
        v2 = **(DWORD **)v3->h_addr_list;
        v4 = DWORD2IpStr(v2, v6);
        DebugPrint1("\"%s\" resolved to %s\n", cp, v4);
      }
      else
      {
        DebugPrint("Unable to resolve hostname \"%s\"\n", cp);
      }
    }
    else if ( a2 )
    {
      *(DWORD *)a2 = 1;
    }
  }
  return v2;
}

//----- (004015C7) --------------------------------------------------------
int PipeProc()//(int a1@<ebp>, int a2@<esi>)
{
  int v2; // ecx
  DWORD *i; // eax
  SOCKET v4; // eax
  int v5; // eax
  int v6; // eax
  const char *v8; // eax
  SOCKET *v9; // edi
  SOCKET v10; // eax
  SOCKET v11; // esi
  SOCKET v12; // eax
  SOCKET v13; // esi
  const char *v14; // eax
  //int v15; // [esp-14h] [ebp-38h]
  //int v16; // [esp-8h] [ebp-2Ch]
  CHAR v17[24]; // [esp-4h] [ebp-28h] BYREF
  char optval[4]; // [esp+0h] [ebp-24h] BYREF
  CHAR v19[24]; // [esp+4h] [ebp-20h] BYREF
  int v20; // [esp+1Ch] [ebp-8h] BYREF
  //int v21; // [esp+20h] [ebp-4h]

  v2 = maxConnections;
  for ( i = (DWORD*)g_sockList; v2; --v2 )
  {
    i[1] = -1;
    *i = -1;
    i += 6;
  }
  //v21 = a2;
  g_sockaddr.sa_family = 2;
  *(WORD *)g_sockaddr.sa_data = htons(g_LFlagPort);
  *(DWORD *)&g_sockaddr.sa_data[2] = g_iFlagIP;
  g_sockTo.sa_family = 2;
  *(WORD *)g_sockTo.sa_data = htons(g_rFlagPort);
  *(DWORD *)&g_sockTo.sa_data[2] = g_destIP;
  g_sockAddrOut.sa_family = 2;
  *(WORD *)g_sockAddrOut.sa_data = htons(g_sFlagSourcePort);
  *(DWORD *)&g_sockAddrOut.sa_data[2] = g_iFlagIP;
  if ( g_UDPFlag )
  {
    *(DWORD *)optval = 1;
    v9 = (SOCKET *)checkIfWeExceedMaxConnections();
    if ( !v9 )
    {
      DebugPrint(aUnableToCreate_0);
      return 0;
    }
    v10 = socket(2, g_type, 0);
    v11 = v10;
    *v9 = v10;
    if ( v10 == -1 )
    {
      DebugPrint(aUnableToCreate_1);
LABEL_20:
      closeInOutConnections(v9);
      return 0;
    }
    if ( bind(v10, &g_sockaddr, 16) == -1 )
    {
      //DebugPrint("Unable to bind to UDP port %d\n", *(DWORD *)&ArgList);
		DebugPrint("Unable to bind to UDP port %d\n", g_LFlagPort);
    }
    else
    {
      setsockopt(v11, 0xFFFF, 4, optval, 4);
      WSAAsyncSelect(v11, g_hWnd, 0xBD1u, 1);
      v12 = socket(2, g_type, 0);
      v13 = v12;
      v9[1] = v12;
      if ( v12 == -1 )
      {
        DebugPrint(aUnableToCreate_2);
        goto LABEL_20;
      }
      if ( bind(v12, &g_sockAddrOut, 16) != -1 )
      {
        WSAAsyncSelect(v13, g_hWnd, 0xBD1u, 1);
        //v15 = *(DWORD *)&ArgList;
        v14 = (const char *)DWORD2IpStr(g_iFlagIP, v19);
        DebugPrint1("Listening for UDP data on %s port %d\n", v14, g_LFlagPort);
        return 1;
      }
      DebugPrint("Unable to bind to UDP port %d\n", g_sFlagSourcePort);
    }
    closeInOutConnections(v9);
    return 0;
  }
  //v21 = a1;
  v20 = 1;
  v4 = socket(2, g_type, 0);
  g_sock = v4;
  if ( v4 == -1 )
  {
    v5 = WSAGetLastError();
    DebugPrint("Unable to create TCP listen socket. %s%d\n", g_szWinsockErrorCode, v5);
    return 0;
  }
  WSAAsyncSelect(v4, g_hWnd, 0xBD0u, 8);
  setsockopt(g_sock, 0xFFFF, 4, (const char *)&v20, 4);
  if ( bind(g_sock, &g_sockaddr, 16) == -1 )
  {
    v6 = WSAGetLastError();
    if ( v6 == 10048 )
      DebugPrint("TCP port %d is already in use by another program", g_LFlagPort);//*(DWORD *)&ArgList
    else
      DebugPrint("Unable to bind to TCP port %d. %s%d", g_LFlagPort, g_szWinsockErrorCode, v6);
    return 0;
  }
  listen(g_sock, 1);
  //v16 = *(DWORD *)&ArgList;
  v8 = (const char *)DWORD2IpStr(g_iFlagIP, v17);
  DebugPrint1("Listening for TCP connections on %s port %d\n", v8, g_LFlagPort);
  return 1;
}
// 4015C7: could not find valid save-restore pair for esi
// 4018B5: using guessed type int sub_4018B5(DWORD);
// 40196D: using guessed type int sub_40196D(void);
// 404C64: using guessed type int dword_404C64;
// 404C80: using guessed type int dword_404C80;
// 407CA0: using guessed type int dword_407CA0;

//----- (0040188E) --------------------------------------------------------
int closeAllConnections()
{
  DWORD v0; // esi
  char *i; // edi
  int result = 0; // eax

  v0 = 0;
  for ( i = g_sockList; v0 < maxConnections; ++v0 )
  {
    //result = sub_4018B5(i);
	closeInOutConnections((SOCKET*)i);
    i += 24;
  }
  return result;
}
// 4018B5: using guessed type int sub_4018B5(DWORD);
// 407CA0: using guessed type int dword_407CA0;

//----- (004018B5) --------------------------------------------------------
void closeInOutConnections(SOCKET *a1)
{
  EnterCriticalSection(&g_csSync);
  if ( a1 )
  {
    if ( a1[1] != -1 )
    {
      DebugPrint1(aClosingOutboun);
      shutdown(a1[1], 2);
      closesocket(a1[1]);
      if ( IsWindow(g_hWnd) )
        WSAAsyncSelect(a1[1], g_hWnd, 0, 0);
      a1[1] = -1;
    }
    if ( *a1 != -1 )
    {
      DebugPrint1(aClosingInbound);
      shutdown(*a1, 2);
      closesocket(*a1);
      if ( IsWindow(g_hWnd) )
        WSAAsyncSelect(*a1, g_hWnd, 0, 0);
      *a1 = -1;
    }
  }
  LeaveCriticalSection(&g_csSync);
}

//----- (0040196D) --------------------------------------------------------
DWORD *checkIfWeExceedMaxConnections()
{
  DWORD *v0; // esi
  DWORD *v1; // ebp
  DWORD v2; // ecx

  v0 = (DWORD*)g_sockList;
  v1 = 0;
  EnterCriticalSection(&g_csSync);
  v2 = 0;
  if ( maxConnections )
  {
    while ( *v0 != -1 || v0[1] != -1 )
    {
      v0 += 6;
      if ( ++v2 >= maxConnections )
        goto LABEL_7;
    }
    v1 = v0;
    v0[2] = 0;
    v0[3] = 0;
    v0[4] = 0;
    v0[5] = 0;
  }
LABEL_7:
  LeaveCriticalSection(&g_csSync);
  return v1;
}
// 407CA0: using guessed type int dword_407CA0;

//----- (004019BD) --------------------------------------------------------
DWORD *addConnectionToPool(SOCKET sock, int a2)
{
  DWORD *v2; // esi
  int v4; // edx
  DWORD *v6; // [esp+Ch] [ebp-8h]
  DWORD v7; // [esp+10h] [ebp-4h]
  int v8; // [esp+1Ch] [ebp+8h]

  v6 = 0;
  v2 = (DWORD*)g_sockList;
  EnterCriticalSection(&g_csSync);
  v7 = 0;
  if ( maxConnections )
  {
    while ( 1 )
    {
      v8 = 0;
      v4 = 0;
      if ( sock == *v2 || !sock )
        v4 = 1;
      if ( a2 == v2[1] || !a2 )
        v8 = 1;
      if ( v4 && v8 )
        break;
      v2 += 6;
      if ( ++v7 >= maxConnections )
        goto LABEL_13;
    }
    v6 = v2;
  }
LABEL_13:
  LeaveCriticalSection(&g_csSync);
  return v6;
}
// 407CA0: using guessed type int dword_407CA0;

//----- (00401A37) --------------------------------------------------------
LPSTR DWORD2IpStr(int a1, LPSTR a2)
{
	BYTE* pBytes = (BYTE*)&a1;

	wsprintfA(a2, "%d.%d.%d.%d", pBytes[0], pBytes[1], pBytes[2], pBytes[3]);
	return a2;
}

//----- (00401A70) --------------------------------------------------------
LRESULT __stdcall WndProc(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
{
  int v5; // edi
  DWORD *v6; // esi
  char *v7; // eax
  unsigned int v8; // edi
  SOCKET *v9; // esi
  SOCKET *v10; // esi
  char *v11; // eax
  char *v12; // eax
  char *v13; // eax
  char *v14; // eax
  u_short v15; // ax
  SOCKET v16; // esi
  char *v17; // eax
  SOCKET *v18; // eax
  SOCKET v19; // esi
  char *v20; // eax
  int v21; // eax
  char *v22; // eax
  char *v23; // eax
  int v24; // esi
  SOCKET *v25; // edi
  int v26; // [esp-14h] [ebp-8F0h]
  int v27; // [esp-Ch] [ebp-8E8h]
  int v28; // [esp-8h] [ebp-8E4h]
  int v29; // [esp-4h] [ebp-8E0h]
  int v30; // [esp-4h] [ebp-8E0h]
  int v31; // [esp-4h] [ebp-8E0h]
  int v32; // [esp-4h] [ebp-8E0h]
  int v33; // [esp-4h] [ebp-8E0h]
  int v34; // [esp-4h] [ebp-8E0h]
  int v35; // [esp-4h] [ebp-8E0h]
  int v36; // [esp-4h] [ebp-8E0h]
  int v37; // [esp-4h] [ebp-8E0h]
  int v38; // [esp-4h] [ebp-8E0h]
  int v39; // [esp-4h] [ebp-8E0h]
  int v40; // [esp-4h] [ebp-8E0h]
  int v41; // [esp-4h] [ebp-8E0h]
  int v42; // [esp-4h] [ebp-8E0h]
  int v43; // [esp-4h] [ebp-8E0h]
  int v44; // [esp-4h] [ebp-8E0h]
  char buf[2048]; // [esp+Ch] [ebp-8D0h] BYREF
  CHAR v46[32]; // [esp+80Ch] [ebp-D0h] BYREF
  CHAR String1[32]; // [esp+82Ch] [ebp-B0h] BYREF
  CHAR v48[32]; // [esp+84Ch] [ebp-90h] BYREF
  CHAR v49[32]; // [esp+86Ch] [ebp-70h] BYREF
  sockaddr v50; // [esp+88Ch] [ebp-50h] BYREF
  sockaddr v51; // [esp+89Ch] [ebp-40h] BYREF
  sockaddr v52; // [esp+8ACh] [ebp-30h] BYREF
  sockaddr name; // [esp+8BCh] [ebp-20h] BYREF
  sockaddr from; // [esp+8CCh] [ebp-10h] BYREF
  SOCKET *Msga; // [esp+8E8h] [ebp+Ch]

  int len = 16;	

  switch ( Msg )
  {
    case 2u:
      ::g_hWnd = 0;
      PostQuitMessage(0);
      return 0;
    case 0xBD0u:
      v8 = HIWORD(lParam);
      switch ( (unsigned __int16)lParam )
      {
        case 1u:
          if ( v8 )
          {
            DebugPrint("Error %d occurred when reading from connection\n", HIWORD(lParam));
            return 0;
          }
          lParam = 16;
		  len = 16;
          v24 = recvfrom(wParam, buf, 2048, 0, &from, &len);
          v25 = (SOCKET*)addConnectionToPool(wParam, 0);
          if ( v25 )
          {
            if ( v24 == -1 )
            {
              v41 = WSAGetLastError();
              DebugPrint("Error %d occurred when reading from inbound connection\n", v41);
            }
            else
            {
              DebugPrint1("%d bytes received from inbound connection\n", v24);
              if ( send(v25[1], buf, v24, 0) != -1 )
                return 0;
              v42 = WSAGetLastError();
              DebugPrint("Error %d occurred when sending to outbound connection\n", v42);
            }
          }
          else
          {
            v25 = (SOCKET*)addConnectionToPool(0, wParam);
            if ( !v25 )
              return 0;
            if ( v24 == -1 )
            {
              v43 = WSAGetLastError();
              DebugPrint("Error %d occurred when reading from outbound connection\n", v43);
            }
            else
            {
              DebugPrint1("%d bytes received from outbound connection\n", v24);
              if ( send(*v25, buf, v24, 0) != -1 )
                return 0;
              v44 = WSAGetLastError();
              DebugPrint("Error %d occurred when sending to inbound connection\n", v44);
            }
          }
          closeInOutConnections(v25);
          return 0;
        case 8u:
          if ( wParam == g_sock )
          {
            if ( v8 )
            {
              v40 = WSAGetLastError();
              DebugPrint("Error %d occurred when accepting remote connection\n", v40);
            }
            else
            {
              lParam = 16;
			  len = 16;
              v16 = accept(wParam, &from, &len);
              if ( v16 == -1 )
              {
                v35 = WSAGetLastError();
                DebugPrint("Error %d occurred when accepting inbound connection\n", v35);
              }
              else
              {
                wParam = 1;
                v36 = ntohs(*(u_short *)from.sa_data);
                v17 = inet_ntoa(*(struct in_addr *)&from.sa_data[2]);
                DebugPrint1("Connection accepted from %s port %d\n", v17, v36);
                v18 = (SOCKET*)checkIfWeExceedMaxConnections();
                Msga = v18;
                if ( v18 )
                {
                  *v18 = v16;
                  v19 = socket(2, g_type, 0);
                  if ( v19 == -1 )
                  {
                    DebugPrint(aUnableToCreate_3);
                    closeInOutConnections(Msga);
                  }
                  else
                  {
                    Msga[1] = v19;
                    setsockopt(v19, 0xFFFF, 4, (const char *)&wParam, 4);
                    if ( bind(v19, &g_sockAddrOut, 16) == -1 )
                    {
                      DebugPrint("Unable to bind to port %d\n", *(DWORD *)&g_sFlagSourcePort);
                      closeInOutConnections(Msga);
                    }
                    else
                    {
                      WSAAsyncSelect(v19, ::g_hWnd, 0xBD0u, 48);
                      v37 = ntohs(*(u_short *)from.sa_data);
                      v20 = inet_ntoa(*(struct in_addr *)&from.sa_data[2]);
                      DebugPrint1("Attempting to connect to %s port %d\n", v20, v37);
                      if ( connect(v19, &g_sockTo, 16) == -1 )
                      {
                        v21 = WSAGetLastError();
                        if ( v21 != 10035 )
                        {
                          if ( v21 == 10048 )
                          {
                            v38 = *(DWORD *)&g_rFlagPort;
                            v22 = inet_ntoa(*(struct in_addr *)&from.sa_data[2]);
                            DebugPrint("%s %s port %d. Address is already in use\n", g_szUnableToConnect, v22, v38);
                          }
                          else
                          {
                            v39 = v21;
                            v28 = *(DWORD *)&g_rFlagPort;
                            v23 = inet_ntoa(*(struct in_addr *)&from.sa_data[2]);
                            DebugPrint("%s %s port %d. Error %d\n", g_szUnableToConnect, v23, v28, v39);
                          }
                          closeInOutConnections(Msga);
                        }
                      }
                    }
                  }
                }
                else
                {
                  DebugPrint(aUnableToCreate_0);
                }
              }
            }
          }
          return 0;
        case 0x10u:
          v10 = (SOCKET*)addConnectionToPool(0, wParam);
          if ( v10 )
          {
            if ( v8 )
            {
              if ( v8 == 10048 )
                DebugPrint("%s. Address is already in use\n", g_szUnableToConnect);
              else
                DebugPrint("%s. Error %d\n", g_szUnableToConnect, v8);
              closeInOutConnections(v10);
            }
            else
            {
			  
              lParam = 16;
              getpeername(*v10, &name, &len);
              v11 = inet_ntoa(*(struct in_addr *)&name.sa_data[2]);
              lstrcpyA(String1, v11);
              lParam = 16;
			  len = 16;
              getsockname(*v10, &v52, &len);
              v12 = inet_ntoa(*(struct in_addr *)&v52.sa_data[2]);
              lstrcpyA(v48, v12);
              lParam = 16;
			  len = 16;
              getsockname(v10[1], &v51, &len);
              v13 = inet_ntoa(*(struct in_addr *)&v51.sa_data[2]);
              lstrcpyA(v46, v13);
              lParam = 16;
			  len = 16;
              getpeername(v10[1], &v50, &len);
              v14 = inet_ntoa(*(struct in_addr *)&v50.sa_data[2]);
              lstrcpyA(v49, v14);
              v34 = ntohs(*(u_short *)v50.sa_data);
              v27 = ntohs(*(u_short *)v51.sa_data);
              v26 = ntohs(*(u_short *)v52.sa_data);
              v15 = ntohs(*(u_short *)name.sa_data);
              DebugPrint(
                "Pipe connected:\n   In: %16s:%-5d --> %s:%d\n  Out: %16s:%-5d --> %s:%d\n",
                String1,
                v15,
                v48,
                v26,
                v46,
                v27,
                v49,
                v34);
              WSAAsyncSelect(*v10, ::g_hWnd, 0xBD0u, 33);
              WSAAsyncSelect(v10[1], ::g_hWnd, 0xBD0u, 33);
            }
          }
          return 0;
        case 0x20u:
          v9 = (SOCKET*)addConnectionToPool(wParam, 0);
          if ( v9 )
          {
            DebugPrint1(aInboundConnect);
          }
          else
          {
            v9 = (SOCKET*)addConnectionToPool(0, wParam);
            if ( !v9 )
              return 0;
            DebugPrint1(aOutboundConnec);
          }
          closeInOutConnections(v9);
          break;
      }
      break;
    case 0xBD1u:
      if ( (unsigned __int16)lParam == 1 )
      {
        if ( HIWORD(lParam) )
        {
          DebugPrint("Error %d occurred when reading from UDP connection\n", HIWORD(lParam));
          return 0;
        }
        lParam = 16;
		len = 16;
        v5 = recvfrom(wParam, buf, 2048, 0, &from, &len);
        v6 = addConnectionToPool(wParam, 0);
        if ( v6 )
        {
          if ( v5 == -1 )
          {
            v29 = WSAGetLastError();
            DebugPrint("Error %d occurred when reading from inbound UDP connection\n", v29);
          }
          else
          {
            DebugPrint1("%d bytes received from inbound UDP connection\n", v5);
            if ( *(DWORD *)&from.sa_data[2] != v6[3] || *(WORD *)from.sa_data != *((WORD *)v6 + 5) )
            {
              *(struct sockaddr *)(v6 + 2) = from;
              v30 = ntohs(*((WORD *)v6 + 5));
              v7 = inet_ntoa(*((in_addr*)&v6[3]));
              DebugPrint1("Setting last UDP source address to %s port %d\n", v7, v30);
            }
            if ( sendto(v6[1], buf, v5, 0, &g_sockTo, 16) != -1 )
              return 0;
            v31 = WSAGetLastError();
            DebugPrint("Error %d occurred when sending to outbound UDP connection\n", v31);
          }
          goto LABEL_22;
        }
        v6 = addConnectionToPool(0, wParam);
        if ( v6 )
        {
          if ( v5 == -1 )
          {
            v32 = WSAGetLastError();
            DebugPrint("Error %d occurred when reading from outbound UDP connection\n", v32);
LABEL_22:
            closeInOutConnections((SOCKET*)v6);
            return 0;
          }
          DebugPrint1("%d bytes received from outbound UDP connection\n", v5);
          if ( !v6[3] || !*((WORD *)v6 + 5) )
          {
            DebugPrint(aDataReceivedFr);
            return 0;
          }
          if ( sendto(*v6, buf, v5, 0, (const struct sockaddr *)(v6 + 2), 16) == -1 )
          {
            v33 = WSAGetLastError();
            DebugPrint("Error %d occurred when sending to inbound UDP connection\n", v33);
            goto LABEL_22;
          }
        }
      }
      break;
    default:
      return DefWindowProcA(hWnd, Msg, wParam, lParam);
  }
  return 0;
}

//----- (004020E2) --------------------------------------------------------
BOOL __stdcall HandlerRoutine(DWORD CtrlType)
{
  BOOL result; // eax

  if ( !g_quitSignal )
  {
    DebugPrint(aQuitSignalDete);
    PostMessageA(g_hWnd, 0x10u, 0, 0);
  }
  result = 1;
  g_quitSignal = 1;
  return result;
}
// 404C5C: using guessed type int dword_404C5C;

//----- (00402113) --------------------------------------------------------
void PrintHelp()
{
  DebugPrint("%s [-hvu?] [-lrs <port>] [-i IP] IP\n\n", g_szWindowName);
  DebugPrint(aHShowsThisHelp);
  DebugPrint(" -c    - maximum allowed simultaneous TCP connections. Default is %d\n", 32);
  DebugPrint(aIListeningInte);
  DebugPrint(aLListeningPort);
  DebugPrint(aRRemotePortNum);
  DebugPrint(aSOutboundSourc);
  DebugPrint(aUUdpMode);
  DebugPrint(aVVerboseMode);
  DebugPrint(aExample);
  DebugPrint(aFpipeL53S53R80);
  DebugPrint(aThisWouldSetTh);
  DebugPrint(aWhenALocalConn);
  DebugPrint(aMadeToPort80Of);
  DebugPrint(aSourcePortForT);
  DebugPrint(aDataSentToAndF);
}

